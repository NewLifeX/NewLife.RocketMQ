# NewLife.RocketMQ 架构设计文档

## 一、总体架构

### 1.1 设计理念

NewLife.RocketMQ 采用**分层清晰、职责单一、可扩展**的架构设计：

- **纯托管实现**：完全使用 C# 实现，无需 Java、gRPC、Protobuf 第三方库
- **双协议支持**：同时支持 Remoting 协议（4.x）和 gRPC 协议（5.x）
- **云厂商适配**：统一 `ICloudProvider` 接口，轻松接入各云服务商
- **高性能优化**：连接复用、对象池、VIP 通道、消息压缩等优化手段
- **可测试性**：30+ 测试类覆盖核心功能和边缘场景

### 1.2 层次结构

```
┌──────────────────────────────────────────────────────────┐
│                      业务层 (MqBase)                      │
│  ┌─────────────────┐         ┌─────────────────┐         │
│  │   Producer      │         │   Consumer      │         │
│  │  生产者业务逻辑  │         │  消费者业务逻辑  │         │
│  └─────────────────┘         └─────────────────┘         │
└──────────────────────────────────────────────────────────┘
                             │
┌──────────────────────────────────────────────────────────┐
│                      通信层 (Client)                      │
│  ┌─────────────────┐  ┌─────────────────┐               │
│  │  ClusterClient  │  │  GrpcClient     │               │
│  │  TCP 长连接管理  │  │  HTTP/2 gRPC   │               │
│  └─────────────────┘  └─────────────────┘               │
│  ┌─────────────────┐  ┌─────────────────┐               │
│  │  NameClient     │  │GrpcMessaging    │               │
│  │  路由发现        │  │Service          │               │
│  └─────────────────┘  └─────────────────┘               │
│  ┌─────────────────┐                                     │
│  │  BrokerClient   │                                     │
│  │  心跳/注销       │                                     │
│  └─────────────────┘                                     │
└──────────────────────────────────────────────────────────┘
                             │
┌──────────────────────────────────────────────────────────┐
│                    协议层 (Protocol)                      │
│  ┌─────────────────┐  ┌─────────────────┐               │
│  │    Command      │  │  GrpcModels     │               │
│  │  Remoting 帧    │  │  gRPC 消息模型  │               │
│  └─────────────────┘  └─────────────────┘               │
│  ┌─────────────────┐  ┌─────────────────┐               │
│  │   MessageExt    │  │  ProtoWriter    │               │
│  │  消息模型        │  │  Protobuf 编码  │               │
│  └─────────────────┘  └─────────────────┘               │
│  ┌─────────────────┐  ┌─────────────────┐               │
│  │  RequestCode    │  │  ProtoReader    │               │
│  │  请求码枚举      │  │  Protobuf 解码  │               │
│  └─────────────────┘  └─────────────────┘               │
└──────────────────────────────────────────────────────────┘
                             │
┌──────────────────────────────────────────────────────────┐
│                   传输层 (Transport)                      │
│  ┌─────────────────┐  ┌─────────────────┐               │
│  │  NewLife.Net    │  │   HttpClient    │               │
│  │  TCP Socket     │  │   HTTP/2        │               │
│  └─────────────────┘  └─────────────────┘               │
└──────────────────────────────────────────────────────────┘
                             │
┌──────────────────────────────────────────────────────────┐
│                 云厂商适配层 (CloudProvider)              │
│  ┌────────┐ ┌────────┐ ┌────────┐ ┌────────┐            │
│  │Aliyun  │ │Huawei  │ │Tencent │ │  ACL   │            │
│  │Provider│ │Provider│ │Provider│ │Provider│            │
│  └────────┘ └────────┘ └────────┘ └────────┘            │
└──────────────────────────────────────────────────────────┘
```

---

## 二、Remoting 协议架构（RocketMQ 4.x/5.x Broker）

### 2.1 协议概述

Remoting 协议是 RocketMQ 的经典 TCP 私有协议，采用**二进制帧格式 + JSON/二进制序列化**，具有高效、稳定的特点。

### 2.2 协议帧格式

```
┌────────────────────────────────────────────────────┐
│                  Remoting 协议帧                    │
├────────┬────────────┬────────────┬─────────────────┤
│ Length │HeaderLength│   Header   │      Body       │
│ 4 bytes│  4 bytes   │  N bytes   │    M bytes      │
└────────┴────────────┴────────────┴─────────────────┘

Length = 4 + N + M （总长度）
HeaderLength 高 8 位：SerializeType (0=JSON, 1=ROCKETMQ)
HeaderLength 低 24 位：实际 Header 长度
```

**协议帧编解码流程**：

```
发送方：
Message → Command.Create() → SetBody() → Build() 
       → [Length][HeaderLength][Header][Body] → TCP Socket

接收方：
TCP Socket → ReadLength(4 bytes) → ReadHeaderLength(4 bytes)
           → ReadHeader(N bytes) → ReadBody(M bytes) 
           → Command.Parse() → Message
```

### 2.3 通信层架构

#### 2.3.1 ClusterClient（集群客户端）

**职责**：
- TCP 连接管理与复用
- 命令发送与响应接收
- HMAC-SHA1 统一签名
- Opaque 请求-响应匹配

**核心流程**：

```
┌─────────────────────────────────────────────────┐
│              ClusterClient 工作流程              │
├─────────────────────────────────────────────────┤
│  1. GetClient(address) - 获取或创建 TCP 连接     │
│  2. SetSignature() - 设置云厂商签名             │
│  3. Invoke() / InvokeAsync() - 发送命令         │
│  4. Opaque 匹配响应                              │
│  5. 响应超时处理                                 │
└─────────────────────────────────────────────────┘
```

**连接复用机制**：

```csharp
// 单连接 Opaque 复用
private ConcurrentDictionary<String, TcpSession> _clients = new();

public TcpSession GetClient(String address)
{
    return _clients.GetOrAdd(address, addr => 
    {
        var client = new TcpSession();
        client.Remote = new NetUri(addr);
        client.Open();
        return client;
    });
}
```

#### 2.3.2 NameClient（名称服务器客户端）

**职责**：
- Topic 路由发现
- 定时轮询路由更新（30s）
- 多 Topic 路由管理
- Broker 主从地址解析

**路由发现流程**：

```
Start() → UpdateRouteAsync()
          ↓
GetRouteInfo(Topic) → NameServer
          ↓
Parse Response:
  - BrokerDatas (Broker 集群信息)
  - QueueDatas (队列分布信息)
          ↓
Build BrokerInfo:
  - MasterAddress (主节点地址)
  - SlaveAddresses (从节点地址列表)
          ↓
Cache & Notify → OnBrokerChange Event
          ↓
定时器 30s 后重复
```

#### 2.3.3 BrokerClient（Broker 客户端）

**职责**：
- Broker 心跳（30s）
- 客户端注销
- 命令收发（继承自 ClusterClient）

**心跳机制**：

```
Start() → SendHeartbeat()
          ↓
Build HeartbeatData:
  - ClientID
  - ProducerDataSet / ConsumerDataSet
          ↓
Send HEART_BEAT (34) → Broker
          ↓
定时器 30s 后重复
```

### 2.4 核心 RequestCode

| 分类 | RequestCode | 值 | 说明 |
|------|------------|:--:|------|
| **消息发送** | SEND_MESSAGE_V2 | 310 | 发送消息V2 |
| | SEND_BATCH_MESSAGE | 320 | 批量发送 |
| | SEND_REPLY_MESSAGE_V2 | 325 | 回复消息 |
| **消息拉取** | PULL_MESSAGE | 11 | 拉取消息 |
| | POP_MESSAGE | 200050 | Pop 消费 |
| | ACK_MESSAGE | 200051 | Pop 确认 |
| **事务消息** | END_TRANSACTION | 37 | 结束事务 |
| | CHECK_TRANSACTION_STATE | 39 | 事务回查 |
| **偏移管理** | QUERY_CONSUMER_OFFSET | 14 | 查询偏移 |
| | UPDATE_CONSUMER_OFFSET | 15 | 更新偏移 |
| | SEARCH_OFFSET_BY_TIMESTAMP | 29 | 按时间戳搜索 |
| **顺序消费** | LOCK_BATCH_MQ | 41 | 锁定队列 |
| | UNLOCK_BATCH_MQ | 42 | 解锁队列 |
| **路由管理** | GET_ROUTEINTO_BY_TOPIC | 105 | Topic 路由 |
| | GET_BROKER_CLUSTER_INFO | 106 | 集群信息 |
| **心跳** | HEART_BEAT | 34 | 心跳 |
| | UNREGISTER_CLIENT | 35 | 注销客户端 |
| | NOTIFY_CONSUMER_IDS_CHANGED | 40 | 消费者变更通知 |

### 2.5 消息编解码

#### 2.5.1 消息发送编码

```
Message → SendMessageRequestHeader
          ↓
Build Command:
  - RequestCode = 310 (SEND_MESSAGE_V2)
  - Header (JSON 或二进制)
  - Body (消息体，可压缩)
          ↓
Check Compress:
  if (Body.Length > CompressOverBytes)
    Body = ZLIB.Compress(Body)
    SysFlag |= 0x1  // 标记压缩
          ↓
Send to Broker
```

#### 2.5.2 消息接收解码

```
Receive from Broker
          ↓
MessageExt.Read(buffer):
  1. Parse SysFlag
  2. Check Compress (SysFlag & 0x1)
     if compressed: Body = ZLIB.Decompress(Body)
  3. Check IPv6 (SysFlag & 0x4)
     if IPv6: IP = 16 bytes
     else: IP = 4 bytes
  4. Parse Properties (Key-Value)
          ↓
Return MessageExt
```

#### 2.5.3 批量消息解码

```
MessageExt.DecodeBatch(body):
  while (offset < body.Length)
  {
    Read TotalSize (4 bytes)
    Read MagicCode (4 bytes)
    Read BodyCRC (4 bytes)
    Read SysFlag (4 bytes)
    Read BornTimestamp (8 bytes)
    Read BornHost (8 bytes, IPv6) or (4 bytes, IPv4)
    Read StoreTimestamp (8 bytes)
    Read StoreHost (8 bytes, IPv6) or (4 bytes, IPv4)
    Read ReconsumeTimes (4 bytes)
    Read PreparedTransactionOffset (8 bytes)
    Read BodyLength (4 bytes)
    Read Body (BodyLength bytes)
    Read TopicLength (1 byte)
    Read Topic (TopicLength bytes)
    Read PropertiesLength (2 bytes)
    Read Properties (PropertiesLength bytes)
    
    Build MessageExt
    offset += TotalSize
  }
  Return List<MessageExt>
```

### 2.6 签名认证机制

#### 2.6.1 HMAC-SHA1 签名流程

```
ClusterClient.SetSignature(request, provider):
  1. Build SignatureData:
     - AccessKey
     - OnsChannel
     - Timestamp
     - RequestData (sorted properties)
  2. HMAC-SHA1(SignatureData, SecretKey)
  3. Add to ExtFields:
     - AccessKey
     - Signature
     - OnsChannel
```

#### 2.6.2 云厂商适配

```
┌─────────────────────────────────────────────────┐
│              ICloudProvider 接口                 │
├─────────────────────────────────────────────────┤
│  - TransformTopic(topic) - 转换主题名            │
│  - TransformGroup(group) - 转换消费组名          │
│  - GetNameServerAddress() - 获取 NameServer     │
└─────────────────────────────────────────────────┘
                     │
    ┌────────────────┼────────────────┐
    │                │                │
┌──────┐      ┌────────┐     ┌────────┐
│Aliyun │      │ Huawei  │     │Tencent  │
│实例ID │      │实例ID + │     │Namespace│
│前缀   │      │SSL/TLS  │     │前缀     │
└───────┘      └─────────┘     └─────────┘
```

---

## 三、gRPC 协议架构（RocketMQ 5.x Proxy）

### 3.1 协议概述

gRPC 协议是 RocketMQ 5.x 引入的新架构，采用 **HTTP/2 + Protobuf** 标准协议，具有以下特点：

- 基于 HTTP/2 多路复用
- Protobuf 二进制序列化
- 支持 Unary（请求-响应）和 Server Streaming（服务端流式）
- 内置轻量级 Protobuf 编解码器（**无外部依赖**）

**仅在 netstandard2.1+ / net5+ 目标框架可用**

### 3.2 gRPC 帧格式

```
┌────────────────────────────────────────────────────┐
│                   gRPC 消息帧                       │
├────────┬────────────┬──────────────────────────────┤
│  Comp  │   Length   │          Body                │
│ 1 byte │  4 bytes   │        N bytes               │
└────────┴────────────┴──────────────────────────────┘

Comp: 0=不压缩, 1=gzip 压缩
Length: 大端序，Protobuf 消息体长度
Body: Protobuf 编码的消息
```

**HTTP/2 请求格式**：

```
POST /apache.rocketmq.v2.MessagingService/{MethodName} HTTP/2
Host: proxy.example.com:8081
Content-Type: application/grpc
X-Mq-Language: DOTNET
X-Mq-Client-Version: 3.0.2026.0701
Authorization: ...

[gRPC 消息帧]
```

### 3.3 通信层架构

#### 3.3.1 GrpcClient（gRPC 客户端）

**职责**：
- HTTP/2 连接管理
- gRPC 帧编解码
- Unary 和 Server Streaming 调用
- 请求超时控制

**核心流程**：

```
┌─────────────────────────────────────────────────┐
│               GrpcClient 工作流程                │
├─────────────────────────────────────────────────┤
│  1. InvokeAsync(service, method, request)       │
│  2. Build HTTP/2 Request                        │
│  3. Encode Request (ProtoWriter)                │
│  4. Send via HttpClient                         │
│  5. Receive Response Stream                     │
│  6. Decode Response (ProtoReader)               │
│  7. Return TResponse                            │
└─────────────────────────────────────────────────┘
```

**Unary 调用**：

```csharp
public async Task<TResponse> InvokeAsync<TRequest, TResponse>(
    String service, String method, TRequest request)
{
    var url = $"{BaseUri}/{service}/{method}";
    var body = ProtoWriter.Encode(request);
    var content = new ByteArrayContent(BuildFrame(body));
    
    var response = await _httpClient.PostAsync(url, content);
    var stream = await response.Content.ReadAsStreamAsync();
    
    return ProtoReader.Decode<TResponse>(stream);
}
```

**Server Streaming 调用**：

```csharp
public async IAsyncEnumerable<TResponse> InvokeStreamAsync<TRequest, TResponse>(
    String service, String method, TRequest request)
{
    var url = $"{BaseUri}/{service}/{method}";
    var body = ProtoWriter.Encode(request);
    var content = new ByteArrayContent(BuildFrame(body));
    
    var response = await _httpClient.PostAsync(url, content, 
        HttpCompletionOption.ResponseHeadersRead);
    var stream = await response.Content.ReadAsStreamAsync();
    
    while (!stream.EndOfStream)
    {
        yield return ProtoReader.Decode<TResponse>(stream);
    }
}
```

#### 3.3.2 GrpcMessagingService（消息服务）

**11 个核心 RPC 方法**：

| 方法 | 类型 | 说明 |
|------|------|------|
| QueryRoute | Unary | 查询主题路由 |
| SendMessage | Unary | 发送消息（普通/延迟/FIFO/事务） |
| QueryAssignment | Unary | 查询队列分配 |
| ReceiveMessage | Server Streaming | 接收消息（长轮询） |
| AckMessage | Unary | 确认消息消费 |
| Heartbeat | Unary | 心跳 |
| EndTransaction | Unary | 结束事务 |
| ForwardToDeadLetterQueue | Unary | 转发到死信队列 |
| ChangeInvisibleDuration | Unary | 修改不可见时间 |
| NotifyClientTermination | Unary | 通知客户端终止 |
| Telemetry | Bidirectional Streaming | 客户端资源上报 |

**发送消息流程**：

```
SendMessageAsync(topic, body, tag, keys, ...)
          ↓
Build GrpcMessage:
  - Topic (GrpcResource)
  - SystemProperties (Tag, MessageType, Keys, ...)
  - UserProperties (自定义属性)
  - Body (消息体)
          ↓
Check MessageType:
  - NORMAL: 普通消息
  - DELAY: DeliveryTimestamp 设置延迟时间
  - FIFO: MessageGroup 设置分组
  - TRANSACTION: 事务消息
          ↓
Build SendMessageRequest
          ↓
GrpcClient.InvokeAsync("SendMessage")
          ↓
Return SendMessageResponse (MessageId, Status, ...)
```

**接收消息流程（Server Streaming）**：

```
ReceiveMessageAsync(topic, group, timeout)
          ↓
Build ReceiveMessageRequest:
  - Group (GrpcResource)
  - MessageQueue (队列信息)
  - LongPollingTimeout (长轮询超时)
          ↓
GrpcClient.InvokeStreamAsync("ReceiveMessage")
          ↓
await foreach (var response in stream)
{
  Process Messages
  Yield return message
}
```

### 3.4 Protobuf 编解码器

NewLife.RocketMQ 内置**轻量级 Protobuf 编解码器**（ProtoWriter/ProtoReader），完全自研，无需依赖 Google.Protobuf 或 protobuf-net。

#### 3.4.1 ProtoWriter（编码器）

**支持的数据类型**：

| Wire Type | 类型 | 说明 |
|-----------|------|------|
| 0 | Varint | int32, int64, uint32, uint64, bool, enum |
| 1 | Fixed64 | fixed64, sfixed64, double |
| 2 | Length-delimited | string, bytes, embedded messages, packed repeated |
| 5 | Fixed32 | fixed32, sfixed32, float |

**编码流程**：

```csharp
public class ProtoWriter
{
    public void WriteTag(Int32 fieldNumber, WireType wireType)
    {
        var tag = (fieldNumber << 3) | (Int32)wireType;
        WriteVarint((UInt32)tag);
    }
    
    public void WriteString(Int32 fieldNumber, String value)
    {
        WriteTag(fieldNumber, WireType.LengthDelimited);
        var bytes = Encoding.UTF8.GetBytes(value);
        WriteVarint((UInt32)bytes.Length);
        Write(bytes);
    }
    
    public void WriteMessage<T>(Int32 fieldNumber, T value)
        where T : IProtoMessage
    {
        var buffer = new MemoryStream();
        var writer = new ProtoWriter(buffer);
        value.WriteTo(writer);
        
        WriteTag(fieldNumber, WireType.LengthDelimited);
        WriteVarint((UInt32)buffer.Length);
        Write(buffer.ToArray());
    }
}
```

#### 3.4.2 ProtoReader（解码器）

**解码流程**：

```csharp
public class ProtoReader
{
    public (Int32 fieldNumber, WireType wireType) ReadTag()
    {
        var tag = ReadVarint();
        var fieldNumber = (Int32)(tag >> 3);
        var wireType = (WireType)(tag & 0x7);
        return (fieldNumber, wireType);
    }
    
    public String ReadString()
    {
        var length = ReadVarint();
        var bytes = Read((Int32)length);
        return Encoding.UTF8.GetString(bytes);
    }
    
    public T ReadMessage<T>() where T : IProtoMessage, new()
    {
        var length = ReadVarint();
        var bytes = Read((Int32)length);
        var stream = new MemoryStream(bytes);
        var reader = new ProtoReader(stream);
        
        var message = new T();
        message.ReadFrom(reader);
        return message;
    }
}
```

#### 3.4.3 gRPC 消息模型

**核心消息类型**：

```csharp
// 资源（Topic/Group）
public class GrpcResource : IProtoMessage
{
    public String ResourceNamespace { get; set; }  // Field 1
    public String Name { get; set; }               // Field 2
}

// 消息
public class GrpcMessage : IProtoMessage
{
    public GrpcResource Topic { get; set; }                        // Field 1
    public IDictionary<String, String> UserProperties { get; set; } // Field 2
    public GrpcSystemProperties SystemProperties { get; set; }      // Field 3
    public Byte[] Body { get; set; }                               // Field 4
}

// 系统属性
public class GrpcSystemProperties : IProtoMessage
{
    public String Tag { get; set; }                  // Field 1
    public IList<String> Keys { get; set; }          // Field 2
    public String MessageId { get; set; }            // Field 3
    public String BornHost { get; set; }             // Field 4
    public DateTime BornTimestamp { get; set; }      // Field 5
    public String MessageGroup { get; set; }         // Field 11 (FIFO)
    public DateTime? DeliveryTimestamp { get; set; } // Field 12 (延迟)
    public GrpcMessageType MessageType { get; set; } // Field 14
}
```

### 3.5 gRPC 特有功能

#### 3.5.1 任意时间延迟消息

Remoting 协议仅支持 18 级预设延迟，gRPC 协议支持任意时间戳延迟：

```csharp
// 延迟到指定时间
var deliveryTime = DateTime.Now.AddMinutes(30);
await producer.PublishDelayViaGrpcAsync("延迟消息", deliveryTime);
```

**实现原理**：

```
GrpcSystemProperties.MessageType = DELAY
GrpcSystemProperties.DeliveryTimestamp = deliveryTime (DateTime)
         ↓
Protobuf Field 12 (timestamp):
  seconds = (deliveryTime - UnixEpoch).TotalSeconds
  nanos = deliveryTime.Millisecond * 1_000_000
         ↓
Proxy 收到后延迟投递到 Topic
```

#### 3.5.2 客户端资源上报（Telemetry）

```
TelemetryViaGrpcAsync()
         ↓
Build TelemetryCommand:
  - Settings (客户端配置)
  - Endpoints (连接端点)
  - Threads (线程数)
  - Language (DOTNET)
         ↓
Build TelemetryRequest
         ↓
GrpcClient.InvokeStreamAsync("Telemetry")
         ↓
Bidirectional Streaming:
  Client → Server: TelemetryCommand
  Server → Client: TelemetryCommand (验证/指令)
```

---

## 四、负载均衡与路由

### 4.1 生产者负载均衡

**ILoadBalance 接口**：

```csharp
public interface ILoadBalance
{
    String Name { get; }
    Boolean Ready { get; set; }
    MessageQueue Select(IList<MessageQueue> queues);
}
```

**WeightRoundRobin（加权轮询）**：

```
Build Queue List:
  For each Broker in Brokers:
    For i in 0..WriteQueueNums:
      Queue { BrokerName, QueueId, Weight = Broker.Weight }
         ↓
Sort by (BrokerName, QueueId)
         ↓
Round Robin with Weight:
  currentWeight[queue] += queue.Weight
  maxWeightQueue = Max(currentWeight)
  currentWeight[maxWeightQueue] -= TotalWeight
  Return maxWeightQueue
```

### 4.2 消费者负载均衡（Rebalance）

**平均分配算法**：

```
Get All Consumers in Group (sorted)
Get All Queues in Topic (sorted)
         ↓
Find My Index in Consumers
         ↓
Allocate Queues:
  averageSize = queues.Count / consumers.Count
  remainder = queues.Count % consumers.Count
  
  if (myIndex < remainder)
    myQueues = queues[(myIndex * (averageSize + 1))..((myIndex + 1) * (averageSize + 1))]
  else
    startIndex = myIndex * averageSize + remainder
    myQueues = queues[startIndex..(startIndex + averageSize)]
         ↓
Lock Queues (if OrderConsume)
         ↓
Start Consume Threads
```

**多 Topic 订阅**：

```
Topics = "topic1;topic2;topic3"
         ↓
For each Topic:
  Get Brokers from NameServer
  Build Queue List
  Rebalance(Topic, Queues)
         ↓
Merge All Queues
Start Consume
```

---

## 五、消息可靠性保证

### 5.1 消费重试机制

```
Consumer.OnConsume() return false
         ↓
SendMessageBackAsync(msg):
  - Topic = "%RETRY%{ConsumerGroup}"
  - DelayLevel = msg.ReconsumeTimes + 3
  - ReconsumeTimes++
         ↓
if (ReconsumeTimes >= MaxReconsumeTimes)
  Topic = "%DLQ%{ConsumerGroup}"  // 进入死信队列
         ↓
Send CONSUMER_SEND_MSG_BACK (36) to Broker
```

### 5.2 事务消息流程

```
1. Producer.PublishTransaction("订单创建")
         ↓
2. Send Half Message (PreparedTransaction = true)
         ↓
3. Execute Local Transaction
         ↓
4. EndTransaction(sendResult, Commit/Rollback)
   - Send END_TRANSACTION (37) to Broker
         ↓
5. Broker 定期回查 (CHECK_TRANSACTION_STATE)
   - Producer.OnCheckTransaction(msg, transactionId)
   - Return TransactionState (Commit/Rollback/Unknown)
```

### 5.3 顺序消费保证

```
Producer:
  SelectQueue(key) - 相同 key 进入同一队列
  Publish(message, queue)
         ↓
Consumer:
  OrderConsume = true
  LockBatchMQAsync(queues) - 向 Broker 申请锁定队列
         ↓
  Single Thread Consume Each Queue
  Offset Commit After Success
         ↓
  UnlockBatchMQAsync(queues) - 释放锁定
```

---

## 六、性能优化策略

### 6.1 连接复用

**Remoting 协议**：
- 单连接 Opaque 复用（RequestId 匹配响应）
- 连接池管理（ConcurrentDictionary）
- 心跳保活（30s）

**gRPC 协议**：
- HTTP/2 多路复用（天然支持）
- HttpClient 连接池

### 6.2 消息压缩

```
if (message.Body.Length > CompressOverBytes)
{
  message.Body = ZLIB.Compress(message.Body);
  message.SysFlag |= 0x1;  // 标记压缩
}
```

**接收端自动解压**：

```
if ((msg.SysFlag & 0x1) != 0)
{
  msg.Body = ZLIB.Decompress(msg.Body);
}
```

### 6.3 VIP 通道

```
if (VipChannelEnabled)
{
  var port = brokerAddress.Port;
  vipAddress = $"{brokerAddress.Host}:{port - 2}";
  client = GetClient(vipAddress);  // 优先级更高的连接
}
```

### 6.4 并发控制

```
private SemaphoreSlim _consumeSemaphore;

public void Start()
{
  _consumeSemaphore = new SemaphoreSlim(MaxConcurrentConsume);
}

await _consumeSemaphore.WaitAsync(cancellationToken);
try
{
  await ProcessMessageAsync(message);
}
finally
{
  _consumeSemaphore.Release();
}
```

---

## 七、扩展性设计

### 7.1 云厂商适配器

```csharp
public interface ICloudProvider
{
    String Name { get; }
    String AccessKey { get; }
    String SecretKey { get; }
    String OnsChannel { get; }
    
    String TransformTopic(String topic);
    String TransformGroup(String group);
    String GetNameServerAddress();
}
```

**实现示例（阿里云）**：

```csharp
public class AliyunProvider : ICloudProvider
{
    public String InstanceId { get; set; }
    
    public String TransformTopic(String topic)
    {
        return $"{InstanceId}%{topic}";
    }
    
    public String TransformGroup(String group)
    {
        return $"{InstanceId}%{group}";
    }
    
    public String GetNameServerAddress()
    {
        // HTTP 接口获取 NameServer 地址
        var url = $"http://MQInstXXX.aliyuncs.com:80/rocketmq/nsaddr4client-internal";
        return HttpGet(url);
    }
}
```

### 7.2 消息钩子

```csharp
public interface ISendMessageHook
{
    void SendMessageBefore(SendMessageContext context);
    void SendMessageAfter(SendMessageContext context);
}

public interface IConsumeMessageHook
{
    void ConsumeBefore(ConsumeMessageContext context);
    void ConsumeAfter(ConsumeMessageContext context);
}
```

**使用场景**：
- 消息轨迹追踪（MessageTraceHook）
- 自定义日志记录
- 性能监控
- 业务拦截

---

## 八、总结

NewLife.RocketMQ 通过**分层清晰、职责单一、可扩展**的架构设计，实现了：

1. **双协议支持**：Remoting（稳定高效）+ gRPC（面向未来）
2. **零外部依赖**：纯 C# 实现，内置 Protobuf 编解码器
3. **多云适配**：统一 ICloudProvider 接口，轻松接入各云服务商
4. **高性能**：连接复用、消息压缩、VIP 通道、并发控制
5. **高可靠**：消费重试、死信队列、事务回查、顺序消费锁定
6. **易扩展**：钩子机制、云厂商适配器、负载均衡接口

---

**文档结束**